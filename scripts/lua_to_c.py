#!/usr/bin/env python3
"""
Compile Lua scripts into C files that can be imported.

Output is xxd-style: each script becomes a C file with:
  - static const unsigned char <name>_lua[] = { ... };
  - static const size_t <name>_lua_len = N;

Use from C with: luaL_loadbuffer(L, (const char*)load_scene_dat_lua, load_scene_dat_lua_len, "@load_scene_dat.lua")

Usage:
  python lua_to_c.py [options] [input_dir] [output_dir]

  input_dir   Directory containing .lua files (default: src/osrs/scripts)
  output_dir  Directory for generated .c files (default: src/osrs/scripts_gen)

Options:
  -h, --help       Show this help
  --header FILE    Also write a header with extern declarations
  --luac PATH      Compile with luac first; PATH is to luac binary (output is bytecode)
  --chunkname FMT  Chunk name format: {name} = base name, e.g. "@{name}.lua"
"""

import argparse
import os
import re
import subprocess
import sys


def script_to_c_symbol(name: str) -> str:
    """Turn script filename into a C-safe symbol (e.g. load_scene_dat.lua -> load_scene_dat_lua)."""
    base = os.path.splitext(name)[0]
    # Allow only alphanumeric and underscore
    safe = re.sub(r"[^a-zA-Z0-9_]", "_", base)
    return f"{safe}_lua"


def bytes_to_c_array(data: bytes, indent: str = "    ", width: int = 12) -> str:
    """Format bytes as C unsigned char array like xxd -i."""
    lines = []
    for i in range(0, len(data), width):
        chunk = data[i : i + width]
        hexes = ", ".join(f"0x{b:02x}" for b in chunk)
        lines.append(f"{indent}{hexes},")
    return "\n".join(lines)


def generate_c_file(
    script_name: str,
    data: bytes,
    out_path: str,
    guard_prefix: str = "OSRS_LUA_EMBED",
) -> None:
    """Write one .c file with the script embedded as a byte array (external linkage for import)."""
    symbol = script_to_c_symbol(script_name)
    guard = f"{guard_prefix}_{symbol.upper()}"
    array_body = bytes_to_c_array(data)
    content = f"""/* Generated by scripts/lua_to_c.py from {script_name} - do not edit */

#include <stddef.h>

#ifndef {guard}
#define {guard}

const unsigned char {symbol}[] = {{
{array_body}
}};

const size_t {symbol}_len = {len(data)};

#endif
"""
    os.makedirs(os.path.dirname(out_path) or ".", exist_ok=True)
    with open(out_path, "w") as f:
        f.write(content)


def generate_header(script_names: list[str], out_path: str, guard_prefix: str = "OSRS_LUA_EMBED") -> None:
    """Write a single header with extern declarations for all embedded scripts."""
    guard = f"{guard_prefix}_H"
    decls = []
    for name in sorted(script_names):
        symbol = script_to_c_symbol(name)
        decls.append(f"extern const unsigned char {symbol}[];")
        decls.append(f"extern const size_t {symbol}_len;")
    content = f"""/* Generated by scripts/lua_to_c.py - do not edit */

#ifndef {guard}
#define {guard}

#include <stddef.h>

"""
    content += "\n".join(decls) + "\n\n#endif\n"
    os.makedirs(os.path.dirname(out_path) or ".", exist_ok=True)
    with open(out_path, "w") as f:
        f.write(content)


def compile_lua_to_bytecode(lua_path: str, luac_path: str) -> bytes:
    """Run luac to produce bytecode; return bytes."""
    result = subprocess.run(
        [luac_path, "-o", "-", "-s", lua_path],
        capture_output=True,
    )
    if result.returncode != 0:
        raise RuntimeError(f"luac failed: {result.stderr.decode(errors='replace')}")
    return result.stdout


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Compile Lua scripts into C files (xxd-style byte arrays).",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "input_dir",
        nargs="?",
        default=os.path.join(os.path.dirname(__file__), "..", "src", "osrs", "scripts"),
        help="Directory containing .lua files",
    )
    parser.add_argument(
        "output_dir",
        nargs="?",
        default=os.path.join(os.path.dirname(__file__), "..", "src", "osrs", "scripts_gen"),
        help="Directory for generated .c files",
    )
    parser.add_argument(
        "--header",
        metavar="FILE",
        help="Also write a header with extern declarations (e.g. scripts_gen/lua_embed.h)",
    )
    parser.add_argument(
        "--luac",
        metavar="PATH",
        help="Compile with luac first; output is bytecode (PATH = luac binary)",
    )
    args = parser.parse_args()

    root = os.path.dirname(os.path.abspath(__file__))
    base = os.path.abspath(os.path.join(root, ".."))
    input_dir = os.path.normpath(os.path.join(base, args.input_dir) if not os.path.isabs(args.input_dir) else args.input_dir)
    output_dir = os.path.normpath(os.path.join(base, args.output_dir) if not os.path.isabs(args.output_dir) else args.output_dir)

    if not os.path.isdir(input_dir):
        print(f"Error: input directory not found: {input_dir}", file=sys.stderr)
        return 1

    lua_files = [f for f in os.listdir(input_dir) if f.endswith(".lua")]
    if not lua_files:
        print(f"No .lua files in {input_dir}", file=sys.stderr)
        return 0

    luac_path = args.luac
    if luac_path and not os.path.isabs(luac_path):
        luac_path = os.path.normpath(os.path.join(base, luac_path))

    generated = []
    for name in lua_files:
        src = os.path.join(input_dir, name)
        with open(src, "rb") as f:
            data = f.read()
        if luac_path:
            try:
                data = compile_lua_to_bytecode(src, luac_path)
            except Exception as e:
                print(f"Warning: luac failed for {name}: {e}", file=sys.stderr)
                # fall back to source
        c_name = script_to_c_symbol(name) + ".c"
        out_path = os.path.join(output_dir, c_name)
        generate_c_file(name, data, out_path)
        generated.append(name)
        print(f"  {name} -> {out_path}")

    if args.header:
        header_path = os.path.normpath(os.path.join(base, args.header) if not os.path.isabs(args.header) else args.header)
        generate_header(generated, header_path)
        print(f"  header -> {header_path}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
