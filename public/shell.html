<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>3D Raster - Model Viewer FX</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #333;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #canvas {
        background-color: #000;
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }

      #soft3d-container {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 400px;
        height: 300px;
        border: 2px solid #ff0000;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        background-color: #000;
        z-index: 1000;
        min-width: 200px;
        min-height: 150px;
      }

      #soft3d-container.dragging {
        cursor: move;
        opacity: 0.8;
      }

      #soft3d-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #soft3d-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 30px;
        background-color: rgba(255, 0, 0, 0.8);
        cursor: move;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 10px;
        box-sizing: border-box;
        user-select: none;
      }

      #soft3d-title {
        color: white;
        font-size: 12px;
        font-weight: bold;
      }

      #soft3d-close {
        color: white;
        font-size: 18px;
        cursor: pointer;
        line-height: 1;
        padding: 0 5px;
      }

      #soft3d-close:hover {
        color: #ffcccc;
      }

      .resize-handle {
        position: absolute;
        background-color: rgba(255, 0, 0, 0.5);
        z-index: 10;
      }

      .resize-handle-n {
        top: 0;
        left: 0;
        right: 0;
        height: 5px;
        cursor: ns-resize;
      }

      .resize-handle-s {
        bottom: 0;
        left: 0;
        right: 0;
        height: 5px;
        cursor: ns-resize;
      }

      .resize-handle-e {
        top: 0;
        right: 0;
        bottom: 0;
        width: 5px;
        cursor: ew-resize;
      }

      .resize-handle-w {
        top: 0;
        left: 0;
        bottom: 0;
        width: 5px;
        cursor: ew-resize;
      }

      .resize-handle-ne {
        top: 0;
        right: 0;
        width: 10px;
        height: 10px;
        cursor: nesw-resize;
      }

      .resize-handle-nw {
        top: 0;
        left: 0;
        width: 10px;
        height: 10px;
        cursor: nwse-resize;
      }

      .resize-handle-se {
        bottom: 0;
        right: 0;
        width: 10px;
        height: 10px;
        cursor: nwse-resize;
      }

      .resize-handle-sw {
        bottom: 0;
        left: 0;
        width: 10px;
        height: 10px;
        cursor: nesw-resize;
      }

      .main-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #fullscreen-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 5px;
        padding: 10px 15px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        z-index: 2000;
        transition: all 0.3s ease;
      }

      #fullscreen-btn:hover {
        background-color: rgba(0, 0, 0, 0.9);
        border-color: rgba(255, 255, 255, 0.8);
        transform: scale(1.05);
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" class="main-canvas"></canvas>
    <button id="fullscreen-btn">⛶ Fullscreen</button>
    <div id="soft3d-container" style="display: none">
      <div id="soft3d-header">
        <span id="soft3d-title">Soft3D View</span>
        <span id="soft3d-close">×</span>
      </div>
      <canvas id="soft3d-canvas"></canvas>
      <div class="resize-handle resize-handle-n"></div>
      <div class="resize-handle resize-handle-s"></div>
      <div class="resize-handle resize-handle-e"></div>
      <div class="resize-handle resize-handle-w"></div>
      <div class="resize-handle resize-handle-ne"></div>
      <div class="resize-handle resize-handle-nw"></div>
      <div class="resize-handle resize-handle-se"></div>
      <div class="resize-handle resize-handle-sw"></div>
    </div>

    <!-- GameIO Integration -->
    <script type="module">
      import { GameIO, RequestStatus } from "./GameIO.js";

      // Create global GameIO instance
      window.gameIO = null;
      window.gameIOInitialized = false;

      // Initialize GameIO
      async function initGameIO(wsUrl = "ws://localhost:8080/") {
        try {
          console.log(`Initializing GameIO with URL: ${wsUrl}`);
          window.gameIO = new GameIO(wsUrl);
          window.gameIO.initialize();
          window.gameIOInitialized = true;
          console.log("GameIO initialized successfully");
          return 1; // Success
        } catch (error) {
          console.error("Failed to initialize GameIO:", error);
          window.gameIOInitialized = false;
          return 0; // Failure
        }
      }

      // Expose GameIO API to Emscripten/Module
      // This will be attached to Module.requestArchive and Module.requestArchiveRead
      window.Module = window.Module || {};

      // Hook to detect when Module is fully loaded
      const originalOnRuntimeInitialized = window.Module.onRuntimeInitialized;
      window.Module.onRuntimeInitialized = function () {
        if (originalOnRuntimeInitialized) {
          originalOnRuntimeInitialized();
        }

        // Set WASM module reference on GameIO
        if (window.gameIO) {
          window.gameIO.setWasmModule(window.Module);
          console.log(
            "WASM Module reference set on GameIO (from onRuntimeInitialized)"
          );
        } else {
          // GameIO not ready yet, store module for later
          console.log("WASM Module loaded, waiting for GameIO initialization");
          window.wasmModuleReady = true;
        }
      };

      window.Module.requestArchive = function (requestId, tableId, archiveId) {
        if (!window.gameIOInitialized || !window.gameIO) {
          console.error("GameIO not initialized");
          return;
        }
        window.gameIO.requestArchive(requestId, tableId, archiveId);
      };

      window.Module.requestArchiveRead = function (buffer, requestId) {
        if (!window.gameIOInitialized || !window.gameIO) {
          console.error("GameIO not initialized");
          return 0;
        }
        return window.gameIO.requestArchiveRead(buffer, requestId);
      };

      window.GameIOAPI = {
        // Initialize GameIO
        init: initGameIO,

        // Set WASM module reference (call this after WASM module is loaded)
        setWasmModule: function (module) {
          if (window.gameIO) {
            window.gameIO.setWasmModule(module);
          }
        },

        // Get request status
        getRequestStatus: function (requestId) {
          if (!window.gameIOInitialized || !window.gameIO) {
            return null;
          }
          if (requestId === 0) {
            return "cached";
          }
          const status = window.gameIO.getRequestStatus(requestId);
          return status || "unknown";
        },

        // Check if a specific archive request is pending
        isRequestPending: function (tableId, archiveId) {
          if (!window.gameIOInitialized || !window.gameIO) {
            return false;
          }
          return window.gameIO.isRequestPending(tableId, archiveId);
        },

        // Get queue length
        getQueueLength: function () {
          if (!window.gameIOInitialized || !window.gameIO) {
            return 0;
          }
          return window.gameIO.getQueueLength();
        },

        // Get current request
        getCurrentRequest: function () {
          if (!window.gameIOInitialized || !window.gameIO) {
            return null;
          }
          return window.gameIO.getCurrentRequest();
        },

        // Get all active requests
        getActiveRequests: function () {
          if (!window.gameIOInitialized || !window.gameIO) {
            return [];
          }
          return window.gameIO.getActiveRequests();
        },

        // Check connection status
        isConnected: function () {
          if (!window.gameIOInitialized || !window.gameIO) {
            return false;
          }
          return window.gameIO.isConnected();
        },

        // Get archive data
        getArchiveData: function (tableId, archiveId) {
          if (!window.gameIOData) {
            return null;
          }
          const key = `${tableId}_${archiveId}`;
          return window.gameIOData.get(key) || null;
        },

        // Get archive data size
        getArchiveDataSize: function (tableId, archiveId) {
          const data = this.getArchiveData(tableId, archiveId);
          return data ? data.byteLength : 0;
        },

        // Copy archive data to WASM heap (for C++ access)
        copyArchiveDataToHeap: function (tableId, archiveId, heapPtr, maxSize) {
          const data = this.getArchiveData(tableId, archiveId);
          if (!data || !Module.HEAPU8) {
            return 0;
          }
          const size = Math.min(data.byteLength, maxSize);
          const srcArray = new Uint8Array(data);
          Module.HEAPU8.set(srcArray.subarray(0, size), heapPtr);
          return size;
        },

        // Clear cached archive data
        clearArchiveData: function (tableId, archiveId) {
          if (!window.gameIOData) {
            return;
          }
          const key = `${tableId}_${archiveId}`;
          window.gameIOData.delete(key);
        },
      };

      // Auto-initialize on load
      window.addEventListener("load", async () => {
        await initGameIO();

        // Set WASM module reference if Module is already loaded
        if (window.Module && window.Module._malloc && window.gameIO) {
          window.gameIO.setWasmModule(window.Module);
          console.log("WASM Module reference set on GameIO (from load event)");
        } else if (window.wasmModuleReady && window.gameIO) {
          window.gameIO.setWasmModule(window.Module);
          console.log(
            "WASM Module reference set on GameIO (deferred from onRuntimeInitialized)"
          );
        } else {
          console.log("Waiting for WASM module to be ready...");
          // Poll for WASM module to be ready
          const checkInterval = setInterval(() => {
            if (window.Module && window.Module._malloc && window.gameIO) {
              window.gameIO.setWasmModule(window.Module);
              console.log("WASM Module reference set on GameIO (from polling)");
              clearInterval(checkInterval);
            }
          }, 100);

          // Clear interval after 10 seconds to prevent infinite polling
          setTimeout(() => clearInterval(checkInterval), 10000);
        }
      });

      console.log(
        "GameIO API exposed to Module.requestArchive and Module.requestArchiveRead"
      );
    </script>

    {{{ SCRIPT }}}

    <script>
      (function () {
        const container = document.getElementById("soft3d-container");
        const header = document.getElementById("soft3d-header");
        const closeBtn = document.getElementById("soft3d-close");
        const canvas = document.getElementById("soft3d-canvas");

        let isDragging = false;
        let isResizing = false;
        let currentHandle = null;
        let startX = 0;
        let startY = 0;
        let startLeft = 0;
        let startTop = 0;
        let startWidth = 0;
        let startHeight = 0;

        // Close button
        closeBtn.addEventListener("click", function (e) {
          e.stopPropagation();
          container.style.display = "none";
        });

        // Dragging functionality
        header.addEventListener("mousedown", function (e) {
          if (e.target === closeBtn) return;
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          const rect = container.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
          container.classList.add("dragging");
          e.preventDefault();
        });

        // Resizing functionality
        const resizeHandles = document.querySelectorAll(".resize-handle");
        resizeHandles.forEach((handle) => {
          handle.addEventListener("mousedown", function (e) {
            isResizing = true;
            currentHandle = handle;
            startX = e.clientX;
            startY = e.clientY;
            const rect = container.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            startWidth = rect.width;
            startHeight = rect.height;
            e.preventDefault();
            e.stopPropagation();
          });
        });

        document.addEventListener("mousemove", function (e) {
          if (isDragging) {
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            container.style.left = startLeft + deltaX + "px";
            container.style.top = startTop + deltaY + "px";
            container.style.right = "auto";
          } else if (isResizing && currentHandle) {
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;

            const classList = currentHandle.classList;
            let newWidth = startWidth;
            let newHeight = startHeight;
            let newLeft = startLeft;
            let newTop = startTop;

            if (
              classList.contains("resize-handle-e") ||
              classList.contains("resize-handle-ne") ||
              classList.contains("resize-handle-se")
            ) {
              newWidth = Math.max(200, startWidth + deltaX);
            }
            if (
              classList.contains("resize-handle-w") ||
              classList.contains("resize-handle-nw") ||
              classList.contains("resize-handle-sw")
            ) {
              newWidth = Math.max(200, startWidth - deltaX);
              newLeft = startLeft + deltaX;
            }
            if (
              classList.contains("resize-handle-s") ||
              classList.contains("resize-handle-se") ||
              classList.contains("resize-handle-sw")
            ) {
              newHeight = Math.max(150, startHeight + deltaY);
            }
            if (
              classList.contains("resize-handle-n") ||
              classList.contains("resize-handle-ne") ||
              classList.contains("resize-handle-nw")
            ) {
              newHeight = Math.max(150, startHeight - deltaY);
              newTop = startTop + deltaY;
            }

            container.style.width = newWidth + "px";
            container.style.height = newHeight + "px";
            container.style.left = newLeft + "px";
            container.style.top = newTop + "px";
            container.style.right = "auto";
          }
        });

        document.addEventListener("mouseup", function () {
          if (isDragging) {
            isDragging = false;
            container.classList.remove("dragging");
          }
          if (isResizing) {
            isResizing = false;
            currentHandle = null;
          }
        });

        // Show container when soft3d-canvas is created/updated
        const observer = new MutationObserver(function (mutations) {
          if (
            canvas.width > 0 &&
            canvas.height > 0 &&
            container.style.display === "none"
          ) {
            container.style.display = "block";
          }
        });
        observer.observe(canvas, {
          attributes: true,
          attributeFilter: ["width", "height"],
        });
      })();

      // Handle window resize to ensure canvas fills screen
      (function () {
        const mainCanvas = document.getElementById("canvas");

        function updateCanvasSize() {
          // The CSS already makes it 100vw x 100vh, but this ensures
          // the internal canvas dimensions are updated on next render
          const rect = mainCanvas.getBoundingClientRect();
          console.log("Window resized: " + rect.width + "x" + rect.height);
        }

        window.addEventListener("resize", updateCanvasSize);

        // Set initial size
        updateCanvasSize();
      })();

      // Fullscreen functionality
      (function () {
        const canvas = document.getElementById("canvas");
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        function toggleFullscreen() {
          if (!document.fullscreenElement) {
            // Request fullscreen
            if (canvas.requestFullscreen) {
              canvas.requestFullscreen();
            } else if (canvas.webkitRequestFullscreen) {
              // Safari
              canvas.webkitRequestFullscreen();
            } else if (canvas.mozRequestFullScreen) {
              // Firefox
              canvas.mozRequestFullScreen();
            } else if (canvas.msRequestFullscreen) {
              // IE/Edge
              canvas.msRequestFullscreen();
            }
          } else {
            // Exit fullscreen
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
              document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
              document.msExitFullscreen();
            }
          }
        }

        // Update button text based on fullscreen state
        function updateFullscreenButton() {
          if (document.fullscreenElement) {
            fullscreenBtn.textContent = "⛶ Exit Fullscreen";
          } else {
            fullscreenBtn.textContent = "⛶ Fullscreen";
          }
        }

        // Button click handler
        fullscreenBtn.addEventListener("click", toggleFullscreen);

        // Listen for fullscreen changes (including ESC key)
        document.addEventListener("fullscreenchange", updateFullscreenButton);
        document.addEventListener(
          "webkitfullscreenchange",
          updateFullscreenButton
        );
        document.addEventListener(
          "mozfullscreenchange",
          updateFullscreenButton
        );
        document.addEventListener("msfullscreenchange", updateFullscreenButton);
      })();
    </script>
  </body>
</html>
