
    texture_definition = texture_definition_new_from_cache(cache, texture_id);
    if( !texture_definition )
        return NULL;

    bool opaque = texture_definition->opaque;
    struct CacheSpritePack** sprite_packs = (struct CacheSpritePack**)malloc(
        texture_definition->sprite_ids_count * sizeof(struct CacheSpritePack*));
    memset(sprite_packs, 0, texture_definition->sprite_ids_count * sizeof(struct CacheSpritePack*));

    for( int i = 0; i < texture_definition->sprite_ids_count; i++ )
    {
        int sprite_id = texture_definition->sprite_ids[i];
        sprite_pack = sprite_pack_new_from_cache(cache, sprite_id);
        assert(sprite_pack);
        if( !sprite_pack )
            continue;

        sprite_packs[i] = sprite_pack;
    }

    for( int i = 0; i < texture_definition->sprite_ids_count; i++ )
    {
        sprite_pack = sprite_packs[i];
        assert(sprite_pack->count > 0);

        palette = sprite_pack->palette;
        palette_length = sprite_pack->palette_length;
        struct CacheSprite* sprite = &sprite_pack->sprites[0];

        palette_pixels = sprite->palette_pixels;

        int* adjusted_palette = (int*)malloc(palette_length * sizeof(int));
        if( !adjusted_palette )
            return NULL;

        for( int pi = 0; pi < palette_length; pi++ )
        {
            int alpha = 0xff;
            // 0xf8f8ff masks off the lower 3 bits of the rgb values.
            // The trick is they can shift bits downward to change the darkness.
            // So the top 5 bits of each color contains the full-bright color.
            if( (palette[pi] & 0xf8f8ff) == 0 )
            {
                // opaque = false;
                alpha = 0;
            }
            adjusted_palette[pi] = (alpha << 24) + gamma_blend(palette[pi], gamma);
        }

        int index = 0;
        if( i > 0 && texture_definition->sprite_types )
            index = texture_definition->sprite_types[i - 1];

        if( index == 0 )
        {
            if( size == sprite->width )
            {
                for( int pixel_index = 0; pixel_index < sprite->width * sprite->height;
                     pixel_index++ )
                {
                    int palette_index = palette_pixels[pixel_index];
                    pixels[pixel_index] = adjusted_palette[palette_index];
                }
            }
            else if( sprite->width == 64 && size == 128 )
            {
                int pixel_index = 0;
                for( int x = 0; x < size; x++ )
                {
                    for( int y = 0; y < size; y++ )
                    {
                        int palette_index = palette_pixels[((x >> 1) << 6) + (y >> 1)];

                        pixels[pixel_index] = adjusted_palette[palette_index];
                        pixel_index++;
                    }
                }
            }
            else
            {
                if( size != 64 && sprite->width != 128 )
                {
                    printf("Invalid size for sprite\n");
                    return NULL;
                }
            }
        }

        free(adjusted_palette);
    }

    for( int i = 0; i < texture_definition->sprite_ids_count; i++ )
    {
        sprite_pack = sprite_packs[i];
        assert(sprite_pack);
        sprite_pack_free(sprite_pack);
    }
    free(sprite_packs);

    texture = (struct Texture*)malloc(sizeof(struct Texture));
    assert(texture);
    texture->texels = pixels;
    texture->width = size;
    texture->height = size;
    texture->opaque = opaque;
    texture->animation_direction = texture_definition->animation_direction;
    texture->animation_speed = texture_definition->animation_speed;
